---

# 🦁 Домашнє завдання (ОНОВЛЕННЯ): Система управління зоопарком - Абстракція та Інтерфейси 🐘

---

Вітаємо у другому етапі створення системи управління зоопарком! 🎉 На цьому етапі ви вдосконалите свою ієрархію, застосувавши принципи **абстракції** та **інтерфейсів**, які ми щойно вивчили. Це дозволить зробити вашу систему більш гнучкою, розширюваною та відповідною стандартам об'єктно-орієнтованого програмування.

## 📋 Опис завдання

Ваше завдання - переробити існуючу ієрархію класів тварин, перетворивши базові класи на **абстрактні** та додавши **інтерфейси** для опису спільних поведінок.

### 🎯 Цілі завдання:
- Закріпити розуміння **абстрактних класів** та **абстрактних методів**.
- Навчитися правильно використовувати **інтерфейси** для опису поведінки.
- Поглибити розуміння принципів **ООП** (абстракція, поліморфізм).
- Зробити код більш гнучким та легким для розширення.

## 📦 Структура пакетів

Структура пакетів залишається тією ж, але тепер ви будете змінювати вміст існуючих файлів та, можливо, додавати нові інтерфейси.

```
src/
└── main/
    └── java/
        └── com/
            └── zoo/
                ├── animals/          # Базові класи тварин
                │   ├── Animal.java
                │   ├── Mammal.java
                │   └── Bird.java
                ├── species/          # Конкретні види тварин
                │   ├── Lion.java
                │   ├── Elephant.java
                │   ├── Eagle.java
                │   └── Penguin.java
                ├── zookeeper/        # Класи працівників
                │   └── ZooKeeper.java
                └── ZooSimulator.java  # Головний клас
```

## 📝 Вимоги до реалізації

### 1. 🐾 Перетворення `Animal` на Абстрактний Клас

Зробіть клас `Animal` **абстрактним**.

- Метод `public abstract void makeSound()` тепер має бути **публічним та абстрактним** у класі `Animal`. Це означає, що кожен конкретний вид тварини (або хоча б ссавці/птахи) зобов'язаний буде реалізувати свою власну версію `makeSound()`.
- Залиште інші поля та методи `Animal` як є.

### 2. 🦌 Перетворення `Mammal` та `Bird` на Абстрактні Класи

Перетворіть класи `Mammal` та `Bird` на **абстрактні**.

- Метод `makeSound()` в `Mammal` та `Bird` тепер буде конкретною реалізацією абстрактного методу з `Animal`.
- Додайте абстрактні методи в `Mammal` та `Bird` для поведінок, які є спільними для всіх ссавців/птахів, але мають специфічну реалізацію для кожного виду. Наприклад:
    - У `Mammal`: абстрактний метод `void move()` (рух).
    - У `Bird`: абстрактний метод `void uniqueBirdAction()` (унікальна дія для птахів, наприклад, `buildNest()` або `sing()`).

### 3. 🌐 Створення Інтерфейсів

Створіть декілька інтерфейсів для опису спільних поведінок, які можуть бути реалізовані різними тваринами, незалежно від їхньої ієрархії спадкування.

- Створіть інтерфейс `IEatable` з методом `void eat()`.
- Створіть інтерфейс `ISleepable` з методом `void sleep()`.
- Створіть інтерфейс `IPlayable` з методом `void play()`.

### 4. 🔗 Застосування Інтерфейсів

Застосуйте створені інтерфейси до відповідних класів:

- Клас `Animal` має реалізовувати інтерфейси `IEatable` та `ISleepable`. Перенесіть об'явлені методі `eat()` та `sleep()` з `Animal` до інтерфейсів (імплементація методів інтерфейсу в абстрактному класі буде реалізовано автоматично, оскільки `Animal` буде імплементувати ці інтерфейси, а його методи `eat()` і `sleep()` вже існують).
- Клас `ZooKeeper` має використовувати методи з цих інтерфейсів для взаємодії з тваринами. Наприклад, `feedAnimal(IEatable animal)` та `playWithAnimal(IPlayable animal)` - таким чином ми користуємося поліморфізмом підтипів очікуючи змінну "Інтерфейсного" типу замість конкретного імплементатора
- **Нова вимога:** Змініть метод `playWithAnimal` у `ZooKeeper` таким чином, щоб він приймав об'єкт типу `IPlayable`, а не `Animal`.
- Додайте реалізацію методу `play()` у клас `Animal` (як частину інтерфейсу `IPlayable`), який буде виводити щось на кшталт "Animal is playing!".
- Кожна конкретна тварина (Lion, Elephant, Eagle, Penguin) має перевизначати метод `play()` для своєї унікальної поведінки під час гри.

### 5. 🦁 Оновлення Конкретних Тварин

Переконайтеся, що всі конкретні класи тварин (`Lion`, `Elephant`, `Eagle`, `Penguin`) коректно:

- Наслідують від оновлених абстрактних класів (`Mammal` або `Bird`).
- Реалізують всі **абстрактні методи**, успадковані від своїх батьківських абстрактних класів.
- Надають власний оверрайд методу `play()` з інтерфейсу `IPlayable`.
    - **Lion**: `move()` - "Lion runs swiftly."
    - **Elephant**: `move()` - "Elephant stomps heavily."
    - **Eagle**: `uniqueBirdAction()` - "Eagle soars high in the sky."
    - **Penguin**: `uniqueBirdAction()` - "Penguin waddles on ice."

### 6. 👨‍🔬 Оновлення Класу `ZooKeeper`

- Оновіть методи `feedAnimal`, `playWithAnimal` та `checkAnimalEnergyLevel` так, щоб вони використовували інтерфейси, де це доречно, замість конкретного класу `Animal`. Це продемонструє поліморфізм та гнучкість.
    - `public void feedAnimal(IEatable animal)`
    - `public void playWithAnimal(IPlayable animal)`
    - `public void checkAnimalEnergyLevel(Animal animal)` (тут Animal залишається, оскільки енергія - це внутрішня властивість базового класу)

### 7. 🎮 Оновлення Класу `ZooSimulator`

- Переконайтеся, що `ZooSimulator` все ще створює та взаємодіє з тваринами, використовуючи нову ієрархію та інтерфейси.
- Продемонструйте використання поліморфізму: створіть масив (або список) типу `Animal` або `IPlayable` і пройдіться по ньому, викликаючи методи.

## ✅ Критерії оцінювання

- ✨ Правильне використання `abstract` ключового слова для класів та методів.
- 🔗 Коректне визначення та реалізація **інтерфейсів**.
- 🔒 Збереження коректних модифікаторів доступу.
- 📦 Правильна організація пакетів.
- 🔄 Використання `super` в конструкторах та методах, де це необхідно.
- 🎯 Перевизначення методів (`@Override`) для абстрактних методів та методів інтерфейсів.
- 🎮 Демонстрація **поліморфізму** у `ZooSimulator` та `ZooKeeper`.
- 📖 Читабельність та документування коду.

## 🤝 Як здавати завдання

1. Реалізуйте всі зміни в існуючих класах згідно з вимогами.
2. Переконайтеся, що код компілюється та працює без помилок.
3. Комітьте та пуште ваші зміни у гілку `main`.
4. Після завершення виконання - додайте відмітьте домашку в Google Classroom зробленою та додайте приватний коментар з посиланням на пул реквест `Feedback` з вашого репозиторію.

**Удачі в програмуванні! 🌟 Нехай ваш зоопарк стане зразком об'єктно-орієнтованого дизайну! 🎊**

---
*💡 Пам'ятайте: Абстракція дозволяє нам зосередитись на тому, "ЩО" об'єкт робить, а не на "ЯК" він це робить, тоді як інтерфейси визначають контракт поведінки!*
